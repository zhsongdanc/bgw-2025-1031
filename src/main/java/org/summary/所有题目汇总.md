# 所有题目汇总

## 一、分布式锁相关题目

### distributedlock.md

**1.Redis分布式锁的8大问题**

(1)非原子操作(set+lua)

(2)忘了释放锁(手动+超时)

(3)释放了其他线程的锁(lua+唯一值)

(4)加锁失败的处理(自旋+睡眠)

(5)锁重入问题(key是锁名+field是请求ID+值加1)

(6)锁竞争问题(读写锁+分段锁)

(7)锁超时失效或锁提前过期问题(自动续期)

(8)主从复制问题(RedLock算法)

**2.Redis的RedLock算法分析**

(1)RedLock算法的两个前提

(2)RedLock算法的具体流程

(3)RedLock算法为什么要这么做

(4)分布式专家Martin对于RedLock的质疑

**3.基于Redis和zk的分布式锁实现原理**

**4.Redis分布式锁的问题**

### distributedlock_2.md

**1.可重入锁源码之lua脚本加锁逻辑**

**2.可重入锁源码之WatchDog维持加锁逻辑**

**3.可重入锁源码之可重入加锁逻辑**

**4.可重入锁源码之锁的互斥阻塞逻辑**

**5.可重入锁源码之释放锁逻辑**

**6.可重入锁源码之获取锁超时与锁超时自动释放逻辑**

**7.可重入锁源码总结**

**8.公平锁源码之加锁和排队**

**9.公平锁源码之可重入加锁**

**10.公平锁源码之队列重排**

**11.公平锁源码之释放锁**

**12.公平锁源码之按顺序依次加锁**

### distributedlock_3.md

**1.读锁RedissonReadLock的获取读锁逻辑**

**2.写锁RedissonWriteLock的获取写锁逻辑**

**3.读锁RedissonReadLock的读读不互斥逻辑**

**4.RedissonReadLock和RedissonWriteLock的读写互斥逻辑**

**5.写锁RedissonWriteLock的写写互斥逻辑**

**6.写锁RedissonWriteLock的可重入逻辑**

**7.读锁RedissonReadLock的释放读锁逻辑**

**8.写锁RedissonWriteLock的释放写锁逻辑**

**9.Redisson联锁MultiLock的加锁与释放锁**

**10.Redisson红锁RedLock的源码实现**

**11.Curator的可重入锁的实现逻辑**

**12.Curator的非可重入锁的实现逻辑**

**13.Curator的可重入读写锁的实现逻辑**

## 二、JUC并发包相关题目

### juc.md

**1.Java集合包源码**

(1)ArrayList源码总结

(2)LinkedList源码总结

(3)ArrayList和LinkedList的区别

(4)栈的数据结构总结

(5)HashMap的源码之数组 + 链表 + 红黑树

(6)HashMap的底层原理总结

(7)迭代器应对多线程并发修改的Fail-Fast机制

**2.Thread源码分析**

(1)线程的运行状态

(2)如何减少线程上下文切换

(3)创建和启动一个线程的主要方法

(4)以daemon模式运行微服务的存活监控线程

(5)Thread线程初始化要点总结

(6)Thread线程的启动源码

(7)yield()方法可切换当前线程执行其他线程

(8)join()方法实现服务注册线程的阻塞式运行

**3.volatile关键字的原理**

**4.Java内存模型JMM**

**5.JMM如何处理并发中的原子性可见性有序性**

**6.volatile如何保证可见性**

**7.volatile的原理(Lock前缀指令 + 内存屏障)**

**8.双重检查单例模式的volatile优化**

**9.synchronized关键字的原理**

**10.wait()与notify()的底层原理**

**11.Atomic原子类中的CAS无锁化原理**

**12.LongAdder的分段CAS优化多线程自旋**

### juc_2.md

**1.JUC中的Lock接口**

**2.如何实现具有阻塞或唤醒功能的锁**

**3.ReentractLock如何获取锁**

**4.AQS的acquire()方法和release()方法总结**

**5.ReentractReadWriteLock的基本原理**

**6.ReentractReadWriteLock如何竞争写锁**

**7.ReentractReadWriteLock如何竞争读锁**

**8.ReentractReadWriteLock的公平锁和非公平锁**

**9.Condition的说明和源码**

**10.等待多线程完成的CountDownLatch**

**11.控制并发线程数的Semaphore**

**12.同步屏障CyclicBarrier**

**13.ConcurrentHashMap的原理**

**14.并发安全的数组列表CopyOnWriteArrayList**

**15.并发安全的链表队列ConcurrentLinkedQueue**

**16.JUC的各种阻塞队列介绍**

**17.LinkedBlockingQueue的具体实现原理**

**18.基于两个队列实现的集群同步机制**

**19.锁优化总结**

**20.线程池介绍**

**21.如何设计一个线程池**

**22.ThreadPoolExecutor线程池的执行流程**

**23.如何合理设置线程池参数 + 定制线程池**

**24.ThreadLocal的设计原理**

**25.Disruptor的生产者源码**

**26.Disruptor的消费者源码**

**27.Disruptor的WaitStrategy等待策略**

**28.Disruptor的高性能原因**

## 三、JVM相关题目

### jvm.md

**一.G1的分区机制和停顿预测模型**

**1.G1垃圾回收器的简介**

**2.HeapRegion是G1内存管理的基本单位**

**3.ParNew +CMS与G1的内存模型对比**

**4.G1如何设置HeapRegion(HR)的大小**

**5.应该如何设置G1的新生代内存大小**

**6.G1新生代扩展流程(新生代分区扩展流程)**

**7.停顿预测模型和衰减算法**

**二.G1的对象分配效率和垃圾回收效率**

### jvm-0.md

**一.Java内存区域**

**1.运行时数据区的介绍**

**2.站在线程的角度看Java内存区域**

**3.深入分析堆和栈的区别**

(1)堆和栈在功能上的区别

(2)堆和栈是线程独享还是线程共享

(3)堆和栈的空间大小对比

(4)堆中创建出来的类的对象不包含类的成员方法

**4.方法的出入栈和栈上分配、逃逸分析及TLAB**

(1)方法会打包成栈帧

(2)栈上分配

(3)逃逸分析

(4)线程本地分配缓冲TLAB

**5.虚拟机中的对象创建步骤**

**6.对象的内存布局**

**二.垃圾回收机制**

**1.如何判断对象存活**

(1)引用计数算法

(2)可达性分析算法

**2.各种引用介绍**

(1)强引用

(2)软引用(SoftReference)

(3)弱引用(WeakReference)

(4)虚引用(PhantomReference)

(5)软引用和弱引用的应用场景

**3.垃圾收集的算法**

(1)标记-清除算法(Mark-Sweep)

(2)标记-复制算法(Copying)

(3)标记-整理算法(Mark-Compact)

(4)是否移动回收后的存活对象分析

(5)CMS收集器如何处理空间碎片过多

**4.垃圾收集器的设计**

(1)分代收集理论的3个假说

(2)垃圾收集器的设计原则

(3)新生代和老年代出现跨代引用的处理

(4)分代收集算法

**5.Serial和Serial Old收集器**

**6.ParNew收集器**

**7.Parallel Scavenge/Parallel Old收集器**

**8.Concurrent Mark Sweep(CMS)收集器**

(1)CMS的阶段(初始标记 + 并发标记 + 重新标记 + 并发清除)

(2)CMS的缺点(资源敏感 + 浮动垃圾 + 内存碎片)

**三.类和类加载相关**

**1.类的生命周期**

**2.类加载的全过程**

(1)加载阶段

(2)验证阶段

(3)准备阶段

(4)解析阶段

(5)类初始化阶段

**3.类加载器**

(1)类加载器的定义及其用途

(2)类加载器与类是否相等

(3)如何重写类的加载方法

**4.双亲委派模型**

(1)JVM角度的两种类加载器

(2)开发者角度的三层类加载器

(3)双亲委派模型各个类加载器之间的关系

(4)双亲委派模型的工作过程

(5)双亲委派模型的好处

(6)双亲委派模型的实现

(7)双亲委派模型被破坏的情形

**5.类加载器和双亲委派机制总结**

(1)启动类加载器

(2)扩展类加载器

(3)应用程序类加载器

(4)自定义类加载器

(5)双亲委派机制

(6)问题

**四.JVM实战总结**

**1.每日百万交易的支付系统的压力**

(1)支付系统每秒要处理多少笔支付订单

(2)每个支付订单处理要耗时多久

(3)每个支付订单大概需要多大的内存空间

(4)每秒发起的支付请求对内存的占用

(5)让支付系统运行起来进行分析

(6)对完整的支付系统内存占用需要进行预估

(7)可以考虑采用4核8G的机器来部署支付系统

(8)总结

**2.JVM内存中的对象何时会被垃圾回收**

**3.JVM垃圾回收的原理核心流程**

**4.CMS是如何工作的**

(1)新生代垃圾回收总结

(2)CMS垃圾回收的基本原理

(3)如果Stop the World然后垃圾回收会如何

(4)如何实现JVM垃圾回收的同时让应用也工作

(5)对CMS的垃圾回收机制进行性能分析

(6)CMS的基本工作原理总结

**5.CMS会产生什么问题**

(1)并发回收垃圾导致CPU资源紧张

(2)Concurrent Mode Failure问题

(3)内存碎片问题

(4)为什么老年代的FGC要比新生代的YGC慢

(6)触发老年代GC的时机总结

**6.哪些情况下对象会进入老年代**

**7.G1垃圾回收器的工作原理**

(1)ParNew + CMS的组合有哪些痛点

(2)G1垃圾回收器介绍

(3)G1如何实现垃圾回收的停顿时间是可控的

(4)Region可能属于新生代也可能属于老年代

(5)总结

**8.G1分代回收原理—性能为何比传统GC好**

(1)G1垃圾回收器的设计思想

(2)如何设定G1对应的内存大小

(3)新生代Region还会分Eden区和Survivor区

(4)G1的新生代垃圾回收

(5)对象什么时候进入老年代

(6)大对象Region

(7)总结

(8)问题

**9.使用G1垃圾回收器时应如何设置参数**

(1)G1的动态内存管理策略总结

(2)何时触发新生代 + 老年代的混合垃圾回收

(3)G1混合垃圾回收的过程

**10.如何基于G1垃圾回收器优化性能**

(1)G1的运行原理总结

(2)新生代GC如何优化

(3)Mixed GC如何优化

**11.使用jstat了解线上系统的JVM运行状况**

(1)新生代对象增长的速率

(2)Young GC的触发频率和每次耗时

(3)每次Young GC后有多少对象进入老年代

(4)Full GC的触发时机和耗时

**12.线上FGC的几种案例**

(1)如何优化每秒十万QPS的社交APP的JVM性能(增加S区大小 + 优化内存碎片)

(2)如何对垂直电商APP后台系统的FGC进行深度优化(定制JVM参数模版)

(3)不合理设置JVM参数可能导致频繁FGC(优化反射的软引用被每次YGC回收)

(4)线上系统每天数十次FGC导致频繁卡顿的优化(大对象问题)

(5)电商大促活动下严重FGC导致系统直接卡死的优化(System.gc()导致)

**13.CPU负载过高的原因**

(1)机器CPU负载过高有两个原因

(2)频繁FGC会导致的两个现象

(3)排查CPU负载过高的原因

(4)排查频繁FGC的问题

(5)基于MAT来进行内存泄漏分析

**14.JVM运行原理和GC原理总结**

**15.JVM性能优化的思路和步骤**

**16.OOM的原因**

## 四、MySQL相关题目

### mysql.md

**一.InnoDB的内存结构和更新机制**

**1.SQL的执行流程**

**2.InnoDB的内存模型**

(1)缓冲池Buffer Pool的默认大小是128MB

(2)数据页是MySQL抽象出来的数据单位

(3)Buffer Pool中每个缓存页都有对应的描述数据

**3.Buffer Pool中的空闲缓存页与free链表**

(1)数据库启动时会按照设置的Buffer Pool大小向OS申请内存

(2)Buffer Pool有一个叫free链表的双向链表

(3)根据free链表的节点可得到一个空闲缓存页

(4)增删改查一条数据时InnoDB引擎会怎么处理

**4.Buffer Pool中的脏页和flush链表**

(1)通过free链表来管理所有空闲的数据页

(2)通过哈希表来管理在Buffer Pool缓存的数据页

(3)通过flush链表来管理更新后等待被刷盘的缓存页

**5.Buffer Pool通过LRU链表来淘汰缓存页**

(1)简单LRU链表的工作原理

(2)简单LRU链表可能存在的问题

(3)基于冷热数据分离思想设计LRU链表

**6.Buffer Pool的缓存页以及几个链表总结**

(1)当加载一个数据页到一个缓存页时

(2)当修改一个缓存页时

(3)当查询一个缓存页时

**7.LRU链表的冷数据区域的缓存页何时刷盘**

时机一：定时把LRU尾部的部分缓存页刷入磁盘

时机二：把flush链表中的一些缓存页定时刷入磁盘

时机三：实在没有空闲缓存页时

**8.增大Buffer Pool来提升MySQL的并发能力**

**二.InnoDB的存储模型**

**1.InnoDB的存储模型以及对应的读写机制**

**2.提交事务时会将redo日志写入磁盘中**

(1)当innodb_flush_log_at_trx_commit = 0时

(2)当innodb_flush_log_at_trx_commit = 1时

(3)当innodb_flush_log_at_trx_commit = 2时

**3.MySQL的redo log和binlog对比**

**4.提交事务时同时也会写入binlog**

**5.在redo日志中写入commit标记的意义**

**6.后台IO线程随机将内存更新后的脏数据刷回磁盘**

**7.InnoDB的执行流程总结**

**8.redo日志和redo log机制的作用**

**9.redo日志会写入日志文件里的Redo Log Blcok**

**10.Redo Log Buffer和Redo Log文件**

**11.redo日志从Redo Log Buffer中刷盘时机**

**12.undo log回滚日志原理**

**13.系统和数据库能抗多少QPS**

**14.性能压测指标和命令**

**15.简单总结增删改SQL语句的实现原理**

**三.并发事务原理**

**四.索引原理和索引优化**

### mysql_2.md

**一.InnoDB的内存结构**

**1.Buffer Pool的概念**

**2.Buffer Pool的Page管理机制**

**3.Change Buffer的概念和作用**

**4.Log Buffer的概念和作用**

**二.InnoDB的存储结构**

**1.InnoDB磁盘结构**

**2.表空间(Tablespaces)**

**3.数据字典(Data Dictionary)**

**4.双写缓冲区(Double Write Buffer Files)**

**5.重做日志(redo log)**

**6.撤销日志(undo log)**

**7.二进制日志(binlog)**

**8.表空间文件结构**

**三.索引优化**

**1.Explain的字段说明**

**2.索引优化原则总结**

**3.慢查询优化思路**

**四.事务原理**

**1.ACID之原子性**

**2.ACID之持久性**

**3.ACID之隔离性**

**4.ACID之一致性**

**5.ACID的关系**

**6.MVCC事务控制**

**五.锁机制原理和索引原理**

### mysql_3.md

注意：该文件内容与jvm.md重复，都是关于G1垃圾回收器的内容。

**一.G1的分区机制和停顿预测模型**

**1.G1垃圾回收器的简介**

**2.HeapRegion是G1内存管理的基本单位**

**3.ParNew +CMS与G1的内存模型对比**

**4.G1如何设置HeapRegion(HR)的大小**

**5.应该如何设置G1的新生代内存大小**

**6.G1新生代扩展流程(新生代分区扩展流程)**

**7.停顿预测模型和衰减算法**

**二.G1的对象分配效率和垃圾回收效率**

## 五、Netty相关题目

### netty.md

**1.TCP和UDP的简介**

**2.TCP连接的三次握手**

**3.TCP连接的四次挥手**

**4.Java IO读写的底层流程**

**5.Linux的IO模型详情**

**6.BIO网络编程**

**7.NIO网络编程之Buffer**

**8.NIO网络编程之组件**

**9.NIO网络编程之Reactor模式**

**10.NIO三大核心组件**

**11.NIO服务端的创建流程**

**12.NIO客户端的创建流程**

**13.NIO优点总结**

**14.NIO问题总结**

**15.Netty服务端的启动流程**

**16.Netty客户端的启动流程**

**17.Netty服务端和客户端使用总结**

**18.TCP粘包拆包**

**19.关于NioEventLoop的问题整理**

**20.NioEventLoop的执行总体框架**

**21.Reactor线程执行一次事件轮询**

**22.Reactor线程处理产生IO事件的Channel**

**23.Reactor线程处理任务队列之添加任务**

**24.Reactor线程处理任务队列之执行任务**

**25.NioEventLoop总结**

**26.关于ByteBuf的问题整理**

**27.零拷贝技术总结**

### netty_2.md

**1.关于Netty客户端连接接入问题整理**

**2.Reactor线程模型和服务端启动流程**

**3.Netty新连接接入的整体处理逻辑**

**4.新连接接入之检测新连接**

**5.新连接接入之创建NioSocketChannel**

**6.新连接接入之绑定NioEventLoop线程**

**7.新连接接入之注册Selector和注册读事件**

**8.注册Reactor线程总结**

**9.新连接接入总结**

**10.Pipeline和Handler的作用和构成**

**11.ChannelHandler的分类**

**12.几个特殊的ChannelHandler**

**13.ChannelHandler的生命周期**

**14.ChannelPipeline的事件处理**

**15.关于ChannelPipeline的问题整理**

**16.ChannelPipeline主要包括三部分内容**

**17.ChannelPipeline的初始化**

**18.ChannelPipeline添加ChannelHandler**

**19.ChannelPipeline删除ChannelHandler**

**20.Inbound事件的传播**

**21.Outbound事件的传播**

**22.ChannelPipeline中异常的传播**

**23.ChannelPipeline总结**

### netty_3.md

**1.关于ByteBuf的问题整理**

**2.ByteBuf的分类**

**3.ByteBuf分类的补充说明**

**4.ByteBuf的主要内容分三大方面**

**5.内存分配器ByteBufAllocator**

**6.ByteBufAllocator的两大子类**

**7.PoolArena分配内存的流程**

**8.Netty的内存规格**

**9.缓存数据结构**

**10.命中缓存的分配流程**

**11.Netty里有关内存分配的重要概念**

**12.Page级别的内存分配**

**13.SubPage级别的内存分配**

**14.ByteBuf的回收**

**15.读数据入口**

**16.拆包原理**

**17.解码器抽象的解码过程总结**

**18.如何把对象变成字节流写到unsafe底层**

**19.Netty的两大性能优化工具**

**20.FastThreadLocal的总结**

**21.Recycler的设计理念**

**22.Recycler的总结**

## 六、Redis相关题目

### redis.md

**一.Redis的数据结构**

**1.Redis的数据结构**

**2.Redis的SDS**

**3.Redis的链表**

**4.Redis的字典**

**5.Redis的跳跃表**

**6.Redis的整数集合**

**7.Redis的压缩列表**

**8.Redis的对象**

**9.Redis的单线程为什么这么快**

**二.Redis的数据库原理**

**1.Redis数据库的构成**

**2.Redis过期键的删除策略**

**3.Redis的RDB持久化**

**4.Redis的AOF持久化**

**5.Redis的AOF重写机制**

**6.Redis基于子进程实现持久化的使用建议**

**7.Redis服务器的文件事件**

**8.Redis服务器的文件事件处理器**

**9.Redis对文件事件的处理流程**

**10.Redis服务器对命令请求的处理**

**三.Redis的复制原理**

**1.Redis使用sync命令实现的复制功能**

**2.Redis使用psync命令实现的复制功能**

**3.Redis主从服务器之间的心跳检测**

**4.从服务器如何实现复制主服务器的(复制的实现)**

**5.Redis的复制拓扑**

**6.Redis主从复制数据延迟的处理**

**7.Redis主从复制的优缺点**

**四.Redis的哨兵原理**

**1.Redis Sentinel和高可用**

**2.Redis如何保存更多的数据**

**3.一个普通Redis服务器的初始化过程**

**4.一个Sentinel服务器的初始化过程**

**5.Sentinel如何向主从服务器获取信息和发送信息**

**6.Sentinel如何检测主客观下线并实现故障转移**

**7.Sentinel客户端的基本实现原理**

**8.Sentinel的基本实现原理(哨兵机制的基本流程)**

**9.关于Sentinel的一些问题**

**五.Redis的集群原理**

**1.Redis Cluster集群的简介**

**2.Redis Cluster集群搭建的步骤**

**3.Redis Cluster集群执行命令的实现原理**

**4.Redis Cluster集群节点通信的实现原理**

**5.Redis Cluster集群复制与故障转移的实现原理**

**6.通过Smart客户端支持Redis Cluster集群**

**7.Redis Cluster集群的补充说明**

**8.Redis Cluster集群的倾斜问题**

**9.Redis Cluster集群的核心问题**

### redis_2.md

注意：该文件内容与jvm.md重复，都是关于G1垃圾回收器的内容。

**一.G1的分区机制和停顿预测模型**

**1.G1垃圾回收器的简介**

**2.HeapRegion是G1内存管理的基本单位**

**3.ParNew +CMS与G1的内存模型对比**

**4.G1如何设置HeapRegion(HR)的大小**

**5.应该如何设置G1的新生代内存大小**

**6.G1新生代扩展流程(新生代分区扩展流程)**

**7.停顿预测模型和衰减算法**

**二.G1的对象分配效率和垃圾回收效率**

## 七、RocketMQ相关题目

### rocketmq.md

**1.RocketMQ生产者是如何发送消息的**

**2.Broker是如何持久化接收到的消息到磁盘上**

**3.基于DLedger技术的Broker主从同步原理**

**4.消费者进行消息拉取和消费的过程**

**5.消费者从Master或Slave上拉取消息的策略**

**6.基于mmap内存映射实现磁盘文件的高性能读写**

**7.Producer基于队列的消息分发机制**

**8.Broker如何实现高并发消息数据写入**

**9.RocketMQ读写队列的运作原理**

**10.Consumer拉取消息的流程原理分析**

**11.ConsumeQueue如何实现高性能消息读取**

**12.CommitLog基于内存的高并发写入优化**

**13.Broker数据丢失场景以及解决方案**

**14.PageCache内存高并发读写问题和处理**

**15.ConsumeQueue异步写入失败的恢复机制**

**16.Broker写入与读取流程性能优化总结**

**17.RocketMQ读写分离主从漂移设计**

**18.RocketMQ为什么采取惰性读写分离模式**

**19.Broker数据与服务是否都实现高可用了**

**20.Broker基于Raft协议的主从架构设计**

**21.Raft协议的Leader选举算法介绍**

**22.Broker基于DLedger的数据写入流程**

**23.Broker基于Raft协议的主从切换机制**

**24.Consumer消息拉取的挂起机制分析**

**25.Consumer的处理队列与并发消费**

### rocketmq_2.md

**1.高并发订单系统面临的技术挑战**

**2.消息中间件的作用**

**3.Kafka、RabbitMQ以及RocketMQ的调研对比**

**4.消息中间件路由中心的架构原理**

**5.Broker的主从架构原理**

**6.高可用的消息中间件生产部署架构**

**7.全链路分析为什么消息会丢失**

**8.RocketMQ的事务消息机制实现发送消息零丢失**

**9.RocketMQ事务消息机制的底层实现原理**

**10.是否可以通过同步重试方案来代替事务消息方案来实现发送消息零丢失**

**11.同步刷盘 + Raft协议同步实现发送消息零丢失**

**12.手动提交offset + 故障自动转移消费消息零丢失**

**13.基于RocketMQ全链路的消息零丢失方案总结**

**14.消息重复 + 处理失败 + 乱序 + 过滤等问题**

**15.RocketMQ的生产实践经验总结**

**16.如何处理RocketMQ的百万消息积压问题**

**17.为RocketMQ增加消息限流功能保证其高可用**

**18.从Kafka迁移到RocketMQ的双写双读方案**

**19.Kafka利用零拷贝和页缓存实现高性能读取**

**20.Kafka集群的分布式存储和高可用**

**21.Kafka的LEO机制和高水位机制**

**22.Kafka的ISR工作原理和机制**

## 八、Sentinel相关题目

### sentinel.md

**1.Sentinel底层的核心概念**

**2.Sentinel中Context的设计思想与源码实现**

**3.Java SPI机制的引入**

**4.Java SPI机制在Sentinel处理链中的应用**

**5.Sentinel默认处理链ProcessorSlot的构建**

### sentinel_2.md

**1.NodeSelectorSlot构建资源调用树**

**2.LogSlot和StatisticSlot采集资源的数据**

**3.Sentinel监听器模式的规则对象与规则管理**

**4.AuthoritySlot控制黑白名单权限**

**5.SystemSlot根据系统保护规则进行流控**

### sentinel_3.md

**1.高并发下的四大限流算法原理及实现**

**2.Guava提供的RateLimiter简介与设计**

**3.继承RateLimiter的SmoothBursty源码**

**4.继承RateLimiter的SmoothWarmingUp源码**

### sentinel_5.md

**1.漏桶算法的实现对比**

**2.令牌桶算法的实现对比**

## 九、ZooKeeper相关题目

### zookeeper.md

**1.ZAB协议和Raft协议的区别**

**2.分布式系统的理论**

**3.两阶段提交Two-Phase Commit(2PC)**

**4.三阶段提交Three-Phase Commit(3PC)**

**5.Paxos岛的故事来对应ZooKeeper**

**6.Paxos算法推导过程**

**7.Paxos协议的核心思想**

**8.ZAB算法简述**

**9.为什么在分布式系统架构中需要使用zk集群**

**10.zk分布式系统具有哪些特点**

**11.zk集群机器的三种角色**

**12.客户端与zk之间的长连接和会话**

**13.zk的数据模型znode和节点类型**

**14.zk最核心的Watcher监听回调机制**

**15.ZAB协议的主从同步机制和崩溃恢复机制**

**16.ZAB协议流程之集群启动-数据同步-崩溃恢复**

**17.采用2PC两阶段提交思想的ZAB消息广播流程**

**18.zk到底是强一致性还是最终一致性**

**19.ZAB协议下两种可能存在的数据不一致问题**

**20.崩溃恢复时新Leader和Follower的数据同步**

**21.ZAB协议会如何处理需要丢弃的消息的**

**22.zk的Observer节点的作用**

**23.zk适合小集群部署 + 读多写少场景的原因**

**24.zk特性的总结**

### zookeeper_2.md

**1.zk实现数据发布订阅**

**2.zk实现负载均衡**

**3.zk实现分布式命名服务**

**4.zk实现分布式协调(Master-Worker协同)**

**5.zk实现分布式通信**

**6.zk实现Master选举**

**7.zk实现分布式锁**

**8.zk实现分布式队列和分布式屏障**

**9.基于Curator进行基本的zk数据操作**

**10.基于Curator实现Leader选举**

**11.基于Curator实现分布式Barrier**

**12.基于Curator实现分布式计数器**

**13.基于Curator实现zk的节点和子节点监听机制**

**14.基于Curator创建客户端实例的源码分析**

**15.Curator在启动时是如何跟zk建立连接的**

**16.基于Curator进行增删改查节点的源码分析**

**17.基于Curator的节点监听回调机制的实现源码**

**18.基于Curator的Leader选举机制的实现源码**

### zookeeper_3.md

**1.ZooKeeper的数据模型与节点类型及应用**

**2.发布订阅模式之用Watcher机制实现分布式通知**

**3.ZooKeeper的网络通信协议**

**4.客户端核心组件HostProvider**

**5.客户端核心组件ClientCnxn**

**6.客户端工作原理之会话创建过程**

**7.单机版的zk服务端的启动过程**

**8.集群版的zk服务端的启动过程**

**9.创建会话**

**10.分桶策略和会话管理**

