# JVM相关题目

## jvm.md

**一.G1的分区机制和停顿预测模型**

**1.G1垃圾回收器的简介**

**2.HeapRegion是G1内存管理的基本单位**

**3.ParNew +CMS与G1的内存模型对比**

**4.G1如何设置HeapRegion(HR)的大小**

**5.应该如何设置G1的新生代内存大小**

**6.G1新生代扩展流程(新生代分区扩展流程)**

**7.停顿预测模型和衰减算法**

**二.G1的对象分配效率和垃圾回收效率**

## jvm-0.md

**一.Java内存区域**

**1.运行时数据区的介绍**

**2.站在线程的角度看Java内存区域**

**3.深入分析堆和栈的区别**

(1)堆和栈在功能上的区别

(2)堆和栈是线程独享还是线程共享

(3)堆和栈的空间大小对比

(4)堆中创建出来的类的对象不包含类的成员方法

**4.方法的出入栈和栈上分配、逃逸分析及TLAB**

(1)方法会打包成栈帧

(2)栈上分配

(3)逃逸分析

(4)线程本地分配缓冲TLAB

**5.虚拟机中的对象创建步骤**

**6.对象的内存布局**

**二.垃圾回收机制**

**1.如何判断对象存活**

(1)引用计数算法

(2)可达性分析算法

**2.各种引用介绍**

(1)强引用

(2)软引用(SoftReference)

(3)弱引用(WeakReference)

(4)虚引用(PhantomReference)

(5)软引用和弱引用的应用场景

**3.垃圾收集的算法**

(1)标记-清除算法(Mark-Sweep)

(2)标记-复制算法(Copying)

(3)标记-整理算法(Mark-Compact)

(4)是否移动回收后的存活对象分析

(5)CMS收集器如何处理空间碎片过多

**4.垃圾收集器的设计**

(1)分代收集理论的3个假说

(2)垃圾收集器的设计原则

(3)新生代和老年代出现跨代引用的处理

(4)分代收集算法

**5.Serial和Serial Old收集器**

**6.ParNew收集器**

**7.Parallel Scavenge/Parallel Old收集器**

**8.Concurrent Mark Sweep(CMS)收集器**

(1)CMS的阶段(初始标记 + 并发标记 + 重新标记 + 并发清除)

(2)CMS的缺点(资源敏感 + 浮动垃圾 + 内存碎片)

**三.类和类加载相关**

**1.类的生命周期**

**2.类加载的全过程**

(1)加载阶段

(2)验证阶段

(3)准备阶段

(4)解析阶段

(5)类初始化阶段

**3.类加载器**

(1)类加载器的定义及其用途

(2)类加载器与类是否相等

(3)如何重写类的加载方法

**4.双亲委派模型**

(1)JVM角度的两种类加载器

(2)开发者角度的三层类加载器

(3)双亲委派模型各个类加载器之间的关系

(4)双亲委派模型的工作过程

(5)双亲委派模型的好处

(6)双亲委派模型的实现

(7)双亲委派模型被破坏的情形

**5.类加载器和双亲委派机制总结**

(1)启动类加载器

(2)扩展类加载器

(3)应用程序类加载器

(4)自定义类加载器

(5)双亲委派机制

(6)问题

**四.JVM实战总结**

**1.每日百万交易的支付系统的压力**

(1)支付系统每秒要处理多少笔支付订单

(2)每个支付订单处理要耗时多久

(3)每个支付订单大概需要多大的内存空间

(4)每秒发起的支付请求对内存的占用

(5)让支付系统运行起来进行分析

(6)对完整的支付系统内存占用需要进行预估

(7)可以考虑采用4核8G的机器来部署支付系统

(8)总结

**2.JVM内存中的对象何时会被垃圾回收**

**3.JVM垃圾回收的原理核心流程**

**4.CMS是如何工作的**

(1)新生代垃圾回收总结

(2)CMS垃圾回收的基本原理

(3)如果Stop the World然后垃圾回收会如何

(4)如何实现JVM垃圾回收的同时让应用也工作

(5)对CMS的垃圾回收机制进行性能分析

(6)CMS的基本工作原理总结

**5.CMS会产生什么问题**

(1)并发回收垃圾导致CPU资源紧张

(2)Concurrent Mode Failure问题

(3)内存碎片问题

(4)为什么老年代的FGC要比新生代的YGC慢

(6)触发老年代GC的时机总结

**6.哪些情况下对象会进入老年代**

**7.G1垃圾回收器的工作原理**

(1)ParNew + CMS的组合有哪些痛点

(2)G1垃圾回收器介绍

(3)G1如何实现垃圾回收的停顿时间是可控的

(4)Region可能属于新生代也可能属于老年代

(5)总结

**8.G1分代回收原理—性能为何比传统GC好**

(1)G1垃圾回收器的设计思想

(2)如何设定G1对应的内存大小

(3)新生代Region还会分Eden区和Survivor区

(4)G1的新生代垃圾回收

(5)对象什么时候进入老年代

(6)大对象Region

(7)总结

(8)问题

**9.使用G1垃圾回收器时应如何设置参数**

(1)G1的动态内存管理策略总结

(2)何时触发新生代 + 老年代的混合垃圾回收

(3)G1混合垃圾回收的过程

**10.如何基于G1垃圾回收器优化性能**

(1)G1的运行原理总结

(2)新生代GC如何优化

(3)Mixed GC如何优化

**11.使用jstat了解线上系统的JVM运行状况**

(1)新生代对象增长的速率

(2)Young GC的触发频率和每次耗时

(3)每次Young GC后有多少对象进入老年代

(4)Full GC的触发时机和耗时

**12.线上FGC的几种案例**

(1)如何优化每秒十万QPS的社交APP的JVM性能(增加S区大小 + 优化内存碎片)

(2)如何对垂直电商APP后台系统的FGC进行深度优化(定制JVM参数模版)

(3)不合理设置JVM参数可能导致频繁FGC(优化反射的软引用被每次YGC回收)

(4)线上系统每天数十次FGC导致频繁卡顿的优化(大对象问题)

(5)电商大促活动下严重FGC导致系统直接卡死的优化(System.gc()导致)

**13.CPU负载过高的原因**

(1)机器CPU负载过高有两个原因

(2)频繁FGC会导致的两个现象

(3)排查CPU负载过高的原因

(4)排查频繁FGC的问题

(5)基于MAT来进行内存泄漏分析

**14.JVM运行原理和GC原理总结**

**15.JVM性能优化的思路和步骤**

**16.OOM的原因**

